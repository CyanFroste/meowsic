use super::Element;
use super::character::{Character, CharacterList, Media as CharacterMedia};
use super::character::{CharacterEntry, id as character_id};
use crate::utils::{HtmlExt, HttpClientExt, StrExt};
use anyhow::{Result, anyhow};
use parking_lot::RwLock;
use scraper::Html;
use std::path::{Path, PathBuf};
use std::sync::Arc;
use std::{array, fs};
use tauri_plugin_http::reqwest::Client as HttpClient;

pub const WIKI_PAGE_BASE_URL: &str = "https://genshin-impact.fandom.com/wiki";

#[derive(Debug, Clone)]
pub struct Api {
    http_client: HttpClient,
    data_dir_path: PathBuf,
    cached_character_list: Arc<RwLock<CharacterList>>,
}

impl Api {
    pub fn new(data_dir_path: impl AsRef<Path>) -> Result<Self> {
        let data_dir_path = data_dir_path.as_ref().join("genshin");
        create_data_subdirs(&data_dir_path)?;

        let http_client = HttpClient::new();
        let cached_character_list = Arc::new(RwLock::new(CharacterList::new()));

        Ok(Self {
            data_dir_path,
            http_client,
            cached_character_list,
        })
    }

    pub fn characters_dir_path(&self) -> PathBuf {
        characters_dir_path(&self.data_dir_path)
    }

    fn character_file_path(&self, id: impl AsRef<Path>) -> PathBuf {
        self.characters_dir_path().join(id).join("index.json")
    }

    pub async fn get_character_list(&self) -> Result<CharacterList> {
        let html = format!("{WIKI_PAGE_BASE_URL}/Character")
            .get_html(&self.http_client)
            .await?;

        let mut data = CharacterList::new();

        let links_selector = "tbody tr td:nth-child(1) a".to_selector()?;
        let links = html
            .select(&".article-table".to_selector()?)
            .next()
            .map(|x| x.select(&links_selector))
            .ok_or_else(|| anyhow!("failed to select character links"))?;

        for el in links {
            if let Some(name) = el.value().attr("title").map(|x| x.to_string()) {
                match name.as_str() {
                    "Traveler" => continue,
                    _ => {
                        let icon = el
                            .child_elements()
                            .next()
                            .and_then(|x| x.value().attr("data-src"))
                            .map(|x| clean_url(x).to_string())
                            .ok_or_else(|| anyhow!("failed to find icon for character: {name}"))?;

                        // let id = character_id(&name); // refer to get_character()
                        let id = name.clone();
                        data.insert(id, CharacterEntry { name, icon });
                    }
                }
            }
        }

        Ok(data)
    }

    async fn get_character_outfit_list(&self, name: impl AsRef<str>) -> Result<Vec<String>> {
        let name = name.as_ref();
        let html = format!("{WIKI_PAGE_BASE_URL}/{name}/Dressing_Room")
            .get_html(&self.http_client)
            .await?;

        let data = html
            .select(&".article-table:first-of-type tbody tr td:nth-child(2) a".to_selector()?)
            .filter_map(|x| x.value().attr("title"))
            .map(|x| x.to_string())
            .collect();

        Ok(data)
    }

    fn get_character_images<const N: usize>(&self, html: &Html) -> Result<[Option<String>; N]> {
        let selector = ".pi-image-collection a".to_selector()?;

        let mut items = html
            .select(&selector)
            .filter_map(|x| x.value().attr("href").map(clean_url));

        Ok(array::from_fn(|_| items.next().map(|x| x.to_string())))
    }

    async fn get_character_base_info(&self, name: impl AsRef<str>) -> Result<Character> {
        let name = name.as_ref();
        let id = name.to_string();
        // let id = character_id(name); // id is most likely the same hash generated by maps

        let icon = if let Some(icon) = {
            self.cached_character_list
                .read()
                .get(&id)
                .map(|x| x.icon.clone())
        } {
            icon
        } else {
            let list = self.get_character_list().await?;
            let icon = list
                .get(&id)
                .map(|x| x.icon.clone())
                .ok_or_else(|| anyhow!("failed to find icon for character: {name}"))?;

            let mut cached = self.cached_character_list.write();
            *cached = list;
            icon
        };

        let html = format!("{WIKI_PAGE_BASE_URL}/{name}")
            .get_html(&self.http_client)
            .await?;

        let quality: u8 = html
            .attr(".portable-infobox [data-source=\"quality\"] img", "alt")?
            .chars()
            .next()
            .and_then(|x| x.to_digit(10))
            .and_then(|x| x.try_into().ok())
            .ok_or_else(|| anyhow!("failed to parse quality for character: {name}"))?;

        let element: Element = html
            .attr(
                ".portable-infobox [data-source=\"element\"].pi-data-value a",
                "title",
            )
            .and_then(|x| x.try_into())?;

        let ascension_materials = html
            .select(&".card-list-container .card-caption a".to_selector()?)
            .take(10)
            .map(|x| x.value().attr("title").map(|x| x.to_string()))
            .collect::<Option<Vec<_>>>()
            .and_then(|x| x.try_into().ok())
            .ok_or_else(|| anyhow!("failed to parse ascension materials for character: {name}"))?;

        let talent_upgrade_materials = html
            .select(&".wikitable.tdc1.thc ~ div .card-caption a".to_selector()?)
            .map(|x| x.value().attr("title").map(|x| x.to_string()))
            .collect::<Option<Vec<_>>>()
            .and_then(|x| x.try_into().ok())
            .ok_or_else(|| {
                anyhow!("failed to parse talent upgrade materials for character: {name}")
            })?;

        let outfits: Vec<String> = vec![];

        let mut media = CharacterMedia {
            icon,
            cards: vec![],
            splashes: vec![],
        };

        match (name, self.get_character_images(&html)?) {
            // Some characters have 2 cards
            ("Furina", [card_1, card_2, splash_1]) => {
                media.cards.push(card_1.ok_or_else(|| {
                    anyhow!("failed to parse card image 1 for character: {name}")
                })?);

                media.cards.push(card_2.ok_or_else(|| {
                    anyhow!("failed to parse card image 2 for character: {name}")
                })?);

                media.splashes.push(splash_1.ok_or_else(|| {
                    anyhow!("failed to parse splash image 1 for character: {name}")
                })?);
            }
            (_, [card_1, splash_1, ..]) => {
                media.cards.push(card_1.ok_or_else(|| {
                    anyhow!("failed to parse card image 1 for character: {name}")
                })?);

                media.splashes.push(splash_1.ok_or_else(|| {
                    anyhow!("failed to parse splash image 1 for character: {name}")
                })?);
            }
        }

        Ok(Character::new(
            name,
            element,
            quality,
            ascension_materials,
            talent_upgrade_materials,
            outfits,
            media,
        ))
    }

    pub async fn get_character(&self, name: impl AsRef<str>) -> Result<Character> {
        let name = name.as_ref();

        let mut character = self.get_character_base_info(name).await?;
        let outfits = self.get_character_outfit_list(name).await?;

        if outfits.len() > 1 {
            let html = format!("{WIKI_PAGE_BASE_URL}/{}", outfits[1])
                .get_html(&self.http_client)
                .await?;

            let [splash_2] = self.get_character_images(&html)?;

            character.media.splashes.push(
                splash_2.ok_or_else(|| {
                    anyhow!("failed to parse splash image 2 for character: {name}")
                })?,
            );
        }

        Ok(character)
    }

    pub async fn save_character(&self, name: impl AsRef<str>) -> Result<()> {
        let character = self.get_character(name).await?;
        let characters_dir_path = self.characters_dir_path();
        let id = character.id();
        let dir_path = characters_dir_path.join(&id);

        fs::create_dir_all(&dir_path).map_err(|err| {
            anyhow!(
                "failed to create character directory: {}. error: {err}",
                dir_path.display()
            )
        })?;

        fs::write(
            self.character_file_path(&id),
            serde_json::to_string_pretty(&character)?,
        )
        .map_err(|err| {
            anyhow!(
                "failed to write character file: {}. error: {err}",
                self.character_file_path(&id).display()
            )
        })?;

        let local_media = character.local_media(&characters_dir_path);

        self.http_client
            .download(&character.media.icon, &local_media.icon)
            .await?;

        for (i, card) in local_media.cards.iter().enumerate() {
            self.http_client
                .download(&character.media.cards[i], card)
                .await?;
        }

        for (i, splash) in local_media.splashes.iter().enumerate() {
            self.http_client
                .download(&character.media.splashes[i], splash)
                .await?;
        }

        Ok(())
    }

    pub fn get_local_character(&self, name: impl AsRef<str>) -> Result<Character> {
        let id = character_id(name);
        let path = self.character_file_path(&id);

        let file = fs::File::open(&path).map_err(|err| {
            anyhow!(
                "failed to open character file: {}. error: {err}",
                path.display()
            )
        })?;

        Ok(serde_json::from_reader(file)?)
    }
}

fn characters_dir_path(data_dir_path: impl AsRef<Path>) -> PathBuf {
    data_dir_path.as_ref().join("characters")
}

fn create_data_subdirs(data_dir_path: impl AsRef<Path>) -> Result<()> {
    for (id, dir_path) in [("characters", characters_dir_path(&data_dir_path))] {
        fs::create_dir_all(&dir_path).map_err(|err| {
            anyhow!(
                "failed to create genshin/{id} directory: {}. error: {err}",
                dir_path.display()
            )
        })?;
    }

    Ok(())
}

fn clean_url(url: &str) -> &str {
    if let Some(i) = url.find("/revision") {
        &url[..i]
    } else {
        url
    }
}
